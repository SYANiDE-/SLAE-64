#!/usr/bin/env python2
import os, sys, random
# heavy dependency on nasmpile and reformat_od.sh being on path!


# randomize loop from selection of odd-numbers, loop over:
	# Pass1:  ripple_XOR
	# Pass2:  NOT

NOTES="""\
ripple_XOR encoder -> NOT encoder.
Chooses random encoder byte based on negation of used bytes in original shellcode
Chooses random odd-number of iterations to loop over pair of encoders
Null bytes found in ending output of any iteration raise exception ValueError
Exception handler recalibrates entire process from beginning.

At end of encoding, builds the .nasm template and compiles, pipes through objdump > reformat_od.sh
"""


def help():
	argc = len(sys.argv)
	if argc == 1:
		print("[#] USAGE: %s [shellcode] {decode mode: [encoder_byte] [iterations]}" 
			% sys.argv[0])
		sys.exit()
	

def Argv_Bytestr(param):
	# takes hex bytes at argv as input
	# variable-defined \x-style bytestring-equivalent output
	this=param.replace("\\x", "").replace("0x", "").replace(",","").replace(" ","")
	bytes = []
	for i in range(0, len(this), 2):
		bytes.append(chr(int(this[i:i+2],16)))
	return ''.join(bytes)


def printer(SS, LL):
	print("[#] hex-to-ascii:")
	try:
		for x in range(0, LL):
			print(chr(bytearray(SS)[x])),
		print("\n[#] \\x-hex:")
		get_hex(SS,LL)
		print("\n[#] 0x-hex:")
		octa=get_oct(SS, LL)
		print(octa)
	except (ValueError, IndexError):
		print("[!] FATAL:  Bad encoding pass... try again")
		sys.exit()
	

def find_avail_magic_byte(SS):
	all_bytes = ["%02x" % x for x in range(1,256)]
	used_bytes = sorted(set(["%02x" % b for b in bytearray(SS)]))
	avail_bytes = [x for x in all_bytes if x not in used_bytes]
	return avail_bytes[random.randrange(0,len(avail_bytes))]


def ripple_XOR(SS, LL, magic):
	bytes = []
	i = 0
	for a in bytearray(SS):
		c = a ^ (int(magic, 16) -i)
		bytes.append("%02x" % c)
		i+=1
	return Argv_Bytestr(''.join(bytes))


def NOT_enc(SS, LL):
	bytes = []
	for a in bytearray(SS):
		b = 0xff
		c = ~a & b
		bytes.append("%02x" % c)
	return Argv_Bytestr(''.join(bytes))
		

def encoder(SS, LL):
	magic_byte = find_avail_magic_byte(SS)
	loop_choices = [ x for x in range(1,100) if not x % 2 == 0 ]
	loop = loop_choices[random.randrange(0, len(loop_choices))]
	iterator = loop
	holder = SS
	while iterator != 0:
		try:
			encode_pass1 = ripple_XOR(holder, LL, magic_byte)
			encode_pass2 = NOT_enc(encode_pass1, LL)
			holder = encode_pass2
			tmp1 = get_oct(encode_pass1, LL)
			tmp2 = get_oct(encode_pass2, LL)
			if not tmp2.find("00") != -1:
				iterator -= 1
			else:
				raise ValueError("Nulls detected in finalout... recalibrating")
		except (ValueError, IndexError):
			magic_byte = find_avail_magic_byte(SS)
			holder = SS
			loop = loop_choices[random.randrange(0, len(loop_choices))]
			iterator = loop
	return holder, magic_byte, loop


def decoder(SS,LL):
	magic_byte = sys.argv[2].replace("\\x", "").replace("0x", "")
	loop = int(sys.argv[3])
	loop = loop if not loop == 0 else 1
	holder = SS
	for i in range(0, loop):
		decode_pass1 = ripple_XOR(holder, LL, magic_byte)
		decode_pass2 = NOT_enc(decode_pass1, LL)
		holder = decode_pass2
	return holder, magic_byte, loop


def builder(SS, magic, loop):
	template="""
; ripXOR-NOT decoder stub
; Author: Chase Hatch
; auto-generated by ripXOR-NOT.py
section .text
global _start
_start:
	jmp short string_call
popper:
	xor ebx, ebx
	xor ecx, ecx
	xor esi, esi
	xor edi, edi
	pop esi
	mov edi, esi
	mov cl, %s
iterator:
	push ecx
	mov cl, scode_len
pass1_decode:
	not byte [esi]
	inc esi
	loop pass1_decode
	mov esi, edi
	mov cl, scode_len
	mov bl, %s
pass2_decode:
	xor byte [esi], bl
	inc esi
	dec bx
	loop pass2_decode
	pop ecx
	loop iterator
	jmp short scode
string_call:
	call popper
	scode 	db	%s	
length_call:
	scode_len:	equ $-scode
""" % (loop, int(magic,16),  SS)
	return template


def get_oct(SS, LL):
	octa = ""
	for x in range(0, LL):
		octa += "0x%02x," % bytearray(SS)[x]
	octa=octa[:-1]
	return octa


def get_hex(SS,LL):
	for x in range(0, LL):
		print("\b\\x%02x" % bytearray(SS)[x]),


def writer(CC, FF):
	with open(FF, 'wb') as F:
		for line in CC:
			F.write(line)
	F.close()


def obj_dumper(FF):
	try:
		print(os.system('nasmpile '  +FF+  " -g -s"))
		print(os.system("objdump -M intel -d " 
			+str(FF).replace(".nasm", ".elf")+  "| reformat_od.sh"))
	except Exception, X:
		print(str(X))


def main():
	help()
	instr = Argv_Bytestr(sys.argv[1])
	inlen = len(bytearray(instr))
	encoded = []
	magic_byte = ""
	loop = 0
	octa = ""	
	file_contents = ""
	decoder_stub_file = "payload.nasm"
	if len(sys.argv) == 2:
		# mode is encode
		encoded, magic_byte, loop = encoder(instr, inlen)	
		print("\n[#] [#] encoded:")
		printer(encoded, inlen)
		print("[#] Magic (random) byte: \\x%s" % magic_byte)
		print("[#] Iterations: %d" % loop)
		octa = get_oct(encoded, inlen)
		file_contents = builder(octa, magic_byte, loop)
		print("[#] [#] [#]  Writing decoder stub:  payload.nasm  [#] [#] [#]:")
		print(file_contents)
		writer(file_contents, decoder_stub_file)
		obj_dumper(decoder_stub_file)
		print("\n[#] Decode-stub + encoded shellcode above, "
			"raw encoded shellcode below [#]\n")
		get_hex(encoded, inlen)	
		print("\n[#] Magic (random) byte: \\x%s" % magic_byte)
		print("[#] Iterations: %d" % loop)
		print("[#] Input SC len: %d" % inlen)
	if len(sys.argv) == 4:
		# mode is decode
		decoded, magic_byte, loop = decoder(instr, inlen)	
		print("\n[#] [#] decoded:")
		printer(decoded, inlen)
		print("[#] Magic (random) byte: \\x%s" % magic_byte)
		print("[#] Iterations: %d" % loop)
		
			
if __name__=="__main__":
	main()

